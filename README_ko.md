<h1 align="center">GitHub Copilot로 Python 프로젝트 업그레이드</h1>
<h5 align="center">레거시 코드에서 최신 안정 버전으로 복잡한 업그레이드 수행</h3>

<p align="center">
  <a href="#mega-prerequisites">사전 준비</a> •
  <a href="#books-resources">리소스</a> •
  <a href="#learning-objectives">학습 목표</a>
</p>

- **대상**: GitHub Copilot을 사용하여 레거시 코드의 복잡한 업그레이드 시나리오를 수행하려는 모든 기술자.
- **학습 내용**: 프로젝트 업그레이드에 특히 유용한 고급 GitHub Copilot 기술을 사용합니다. 이러한 기술과 패턴은 프로젝트 업그레이드 및 개편뿐만 아니라 처음부터 개발하는 데에도 적용할 수 있습니다.
- **구축 결과물**: Python 2.5를 사용하여 작성된 레거시 및 더 이상 사용되지 않는 구문을 최신 Python 3 버전으로 업그레이드한 완전 개편된 Python 프로젝트.

> [!NOTE]
> 워크숍을 찾고 계신가요? [워크숍 디렉터리](./workshop)로 이동하세요.

## 학습 목표

이 워크숍에서 다음을 수행합니다:

  - 레거시 프로젝트를 다루기 위한 고급 GitHub Copilot 상호작용 기술 사용
  - 레거시 프로젝트를 업그레이드하고 정확성을 검증하기 위해 반복, 검증 및 세부 조정
  - 제안을 개선하고 더 나은 결과를 얻을 수 있는 다양한 전략을 선택하는 데 유용한 일반 개념 적용
  - 업그레이드 후 프로젝트의 잠재적 문제를 식별하고 최종 상태를 검증하는 철저한 테스트 전략 구축

## :mega: 사전 준비

워크숍에 참여하기 전에 필요한 것은 단 하나, 공개 GitHub 계정입니다. 모든 리소스, 종속성 및 데이터는 저장소 자체에 포함되어 있습니다. GitHub Copilot 라이선스, 체험판 또는 무료 버전을 보유하고 있는지 확인하세요.

## 주요 포인트

### 1. 명확한 목표와 요구 사항 정의

*무엇을 달성해야 하나요?*

먼저 최종 목표를 명확히 이해하세요. 원하는 결과는 무엇인가요? 레거시 프로젝트를 업그레이드하려면 중요한 변경 사항을 수행할 때 정확성과 완료를 검증할 수 있는 철저한 테스트 전략을 보장해야 합니다.

*제약 조건은 무엇인가요?*

제한 사항이나 제외 사항을 식별하세요. 예를 들어, 대규모 언어 모델(LLM)은 적절한 제안을 제공하기에 충분한 컨텍스트를 가질 수도 있고 없을 수도 있습니다. 목표를 달성하기 위해 결정을 내리는 것은 운전자인 여러분의 몫입니다. 특정 비즈니스 로직은 다른 외부 라이브러리나 기능을 추가하지 못하도록 방해할 수 있습니다. 예를 들어, 프로덕션 환경에서 사용되는 프로젝트를 업그레이드하는 경우 기존 코드를 손상시킬 수 있는 새로운 라이브러리나 기능을 추가할 수 없습니다.

> [!TIP]
> 문제의 범위를 정확히 설정하는 데 집중하세요. 확신이 서지 않으면 넓게 시작한 후 점진적으로 세부 사항을 좁혀 나가세요.

### 2. 문제를 구성 요소로 나누기

문제를 더 작고 관리 가능한 부분으로 분해하세요. 예를 들어, 핵심 애플리케이션 구성 요소로 시작한 다음 단일 API 엔드포인트나 라이브러리 함수를 테스트하세요. 이렇게 하면 문제를 단계별로 이해하고 해결하기가 더 쉬워집니다:

- 단일 공개, 노출된 함수 또는 API 엔드포인트
- 테스트, 테스트 설정 및 검증 스크립트
- 구성 및 설치 프로세스

각 조건을 단계별로 적용하고 있는지 확인하세요. 프로그래밍에서는 복잡한 함수를 더 작은 헬퍼 함수로 나누면 작성 및 디버그가 더 쉬워질 수 있습니다.

> [!TIP]
> 분해는 복잡성을 다루는 훌륭한 방법입니다. 한 번에 하나의 작은 작업에 집중할 수 있습니다.

### 3. 작업 단위 생성

작업 단위는 전체 문제의 작고 관리 가능한 부분입니다. 이는 문제를 구성 요소로 나누는 것과 유사하지만, 완료해야 할 특정 작업에 중점을 둡니다. 이를 기능 테스트와 유사하게 생각하세요. 특정 기능이나 기능을 검증합니다. 예를 들어, 레거시 프로젝트를 업그레이드하는 경우 단일 라이브러리나 함수 업그레이드에 중점을 둔 작업 단위를 생성할 수 있습니다.

이렇게 하면 한 번에 하나의 작은 작업에 집중할 수 있으며, 변경 사항을 테스트하고 검증하기가 더 쉬워집니다.

> [!TIP]
> 작업 단위를 생성할 때 변경 사항을 쉽게 테스트할 수 있도록 기능 테스트를 고려하세요. 이는 변경 사항을 검증하는 간단한 테스트 스크립트를 생성하거나 프로젝트의 모든 테스트를 실행하는 테스트 스위트를 생성하는 것만큼 간단할 수 있습니다.

### 4. 솔루션 반복 및 세부 조정

간단하게 시작한 다음 세부 조정하세요. 복잡한 문제에서는 초기 시도가 완벽하지 않은 경우가 많습니다. 기본 솔루션을 생성한 다음 점진적으로 이를 개선하세요.

> [!TIP]
> 각 반복마다 예상 결과와 비교하여 결과가 올바른 방향으로 진행되고 있는지 확인하세요.

### 5. 요구 사항을 명확히 하기 위해 예제 사용

AI 모델에 대한 프롬프트를 생성하거나 문제를 설명할 때 예제를 제공하세요. 예제는 기대치를 설명하여 문제를 해결하는 데 관여하는 사람이나 도구(GitHub Copilot과 같은)에게 작업을 더 명확히 전달할 수 있습니다.

예를 들어, 레거시 코드의 경우 입력 및 예상 출력이 무엇인지 설명하면서 작업을 수행하는 논리를 포함할 수 있습니다.

> [!TIP]
> 예제 기반 문제 해결은 이해를 맞추는 데 도움이 됩니다. 특히 모호한 작업에 유용합니다.

### 6. 패턴 식별 및 솔루션 재사용

문제에서 공통 패턴을 인식하고 적용 가능한 경우 솔루션을 재사용하세요. 레거시 Python 프로젝트의 명백한 예는 Python 2.5에서의 예외 처리가 Python 3+에서 `SyntaxError`를 생성하는 경우입니다.

레거시 프로젝트에서는 두 가지 경우를 처리하거나 Python 버전에 따라 가져오기를 수행할 수 있는 모듈을 생성하는 함수가 일반적입니다. 이는 다른 프로젝트에서도 재사용할 수 있는 레거시 프로젝트의 일반적인 패턴입니다.

> [!TIP]
> 패턴을 인식하는 것은 경험의 상징입니다. 유사한 문제를 반복적으로 접하다 보면 프로세스를 가속화할 수 있는 유사성을 발견하게 될 것입니다.

### 7. 제약 조건 및 엣지 케이스를 사용하여 견고성 확보

엣지 케이스와 예외를 고려하세요. 복잡한 문제는 종종 "이상적인" 데이터뿐만 아니라 "엣지" 또는 "이례적인" 케이스도 처리해야 합니다. 프롬프트나 솔루션이 이러한 엣지 케이스를 고려하도록 하세요.

레거시 코드에서는 코드가 예상치 못한 입력으로 어떻게 동작하는지 고려해야 하며, 이는 새로운 테스트를 작성하거나 기존 테스트를 수정하도록 안내할 수 있습니다.

> [!TIP]
> 엣지 케이스를 고려하면 더 탄력적이고 일반화된 솔루션을 구축할 수 있습니다. 변경 사항을 검증하고 견고한 테스트 스위트를 생성하는 데 추가적인 강조를 두세요.

### 8. 도구를 효과적으로 사용

GitHub Copilot, 편집기 자동 완성 또는 기타 자동화 도구를 사용하든, 사용할 수 있는 도구를 활용하되 올바른 컨텍스트로 이를 안내하세요. 도구는 생성 속도를 높이는 데 유용하지만, 여전히 잘 구조화된 입력과 검증이 필요합니다.

GitHub Copilot의 경우 프롬프트가 상세하지만 간결한지 확인하세요. 도구는 구조화된 입력을 제공할 때 가장 잘 작동하며 모호성이 적습니다.

> [!TIP]
> 도구를 구체적으로 사용하되, 도구가 항상 컨텍스트를 완전히 이해하지 못할 수 있으므로 결과를 확인하세요.

### 9. 테스트 및 검증

테스트 및 검증은 솔루션이 예상대로 작동하는지 확인하는 데 중요합니다. 레거시 코드의 경우, 새로운 코드가 이전 코드와 유사하게(또는 정확히 동일하게) 동작하는지 확인하고자 할 때 더욱 중요합니다.

테스트는 예상 및 예상치 못한 상황이 올바르게 처리되었는지 확인합니다.

> [!TIP]
> 프로세스 초기에 실수를 잡기 위해 항상 검증 단계를 포함하세요.

다른 사용 사례에 대한 일반화:
코드 또는 알고리즘 작성: 함수, 클래스 또는 워크플로를 생성할 때도 동일한 개념이 적용됩니다. 입력, 예상 출력, 엣지 케이스를 명확히 정의하고 반복하여 세부 조정합니다.

AI 모델 프롬프트: 복잡한 작업(코드, 텍스트 또는 디자인 생성 등)을 요청할 때 명확한 목표를 설정하고, 문제를 분해하고, 컨텍스트를 제공하며 반복합니다.

디자인 또는 콘텐츠 생성: 목적을 정의하고, 디자인 요소를 분해하며, 예제나 영감을 제공한 다음 피드백을 기반으로 세부 조정합니다.

최종 생각:
복잡한 생성 문제는 종종 명확성, 분해, 반복 및 검증의 균형을 포함합니다. SQL 쿼리든 다른 작업이든 이러한 개념을 염두에 두면 더 정확하고 효율적이며 신뢰할 수 있는 결과를 생성할 수 있습니다.



## :books: 리소스

필수는 아니지만, 이 워크숍에서 다루는 일부 기능은 다음 Microsoft Learning 모듈에 포함되어 있습니다:

- [GitHub Codespaces로 코딩](https://learn.microsoft.com/training/modules/code-with-github-codespaces/)
- [고급 GitHub Copilot 기능 사용](https://learn.microsoft.com/training/modules/advanced-github-copilot/)

## 기여

이 프로젝트는 기여와 제안을 환영합니다. 대부분의 기여는 귀하가 기여할 권리가 있으며 실제로 그렇게 한다는 것을 선언하는 기여자 라이선스 계약(CLA)에 동의해야 합니다. 자세한 내용은 https://cla.opensource.microsoft.com을 방문하세요.

풀 리퀘스트를 제출하면 CLA 봇이 자동으로 CLA 제공 여부를 결정하고 PR에 적절히 표시합니다(예: 상태 확인, 댓글). 봇에서 제공하는 지침을 따르기만 하면 됩니다. 이 작업은 CLA를 사용하는 모든 저장소에서 한 번만 수행하면 됩니다.

이 프로젝트는 [Microsoft 오픈 소스 행동 강령](https://opensource.microsoft.com/codeofconduct/)을 채택했습니다. 자세한 내용은 [행동 강령 FAQ](https://opensource.microsoft.com/codeofconduct/faq/)를 참조하거나 [opencode@microsoft.com](mailto:opencode@microsoft.com)으로 추가 질문이나 의견을 보내주세요.

## 상표

이 프로젝트에는 프로젝트, 제품 또는 서비스에 대한 상표 또는 로고가 포함될 수 있습니다. Microsoft 상표 또는 로고의 허가된 사용은 [Microsoft 상표 및 브랜드 지침](https://www.microsoft.com/en-us/legal/intellectualproperty/trademarks/usage/general)을 준수해야 합니다. 수정된 버전의 이 프로젝트에서 Microsoft 상표 또는 로고를 사용하는 경우 혼란을 야기하거나 Microsoft 후원을 암시해서는 안 됩니다. 제3자 상표 또는 로고의 사용은 해당 제3자의 정책을 따릅니다.
